generator bit expBoolean(int nvars, int nconsts, int bnd, int[nvars] vars, int[nconsts] consts){

    if (bnd == 0) {
        return false;
    }
    int t = ??;
    if (t ==0) {
        return false;
    }
    if (t ==1) {
        bit t1 = expBoolean(nvars, nconsts, (bnd-1), vars, consts);
        return !t1;
    }
    if (t ==2) {
        bit t1 = expBoolean(nvars, nconsts, bnd-1, vars, consts);
        bit t2 = expBoolean(nvars, nconsts, bnd-1, vars, consts);
        return t1 < t2;
    }
    if (t ==3) {
        bit t1 = expBoolean(nvars, nconsts, bnd-1, vars, consts);
        bit t2 = expBoolean(nvars, nconsts, bnd-1, vars, consts);
        return t1 && t2;
    }
}

generator int expInteger(int nvars, int nconsts, int bnd, int[nvars] vars, int[nconsts] consts){
    //In this generator, nvars is the number of variables and nconsts is the number of constants.
    //the array vars contains the values of all the variables and the array consts of all the constants.
    //Note that unlike problem 1, where you were generating ASTs, here you are synthesizing the actual function.
    //Also note that you will probably need a separate generator for the boolean expressions.
    if (bnd == 0) {
        int nconstant = ??;
        return consts[nconstant];
    }
    int t = ??;
    if (t == 0) {
        int nconstant = ??;
        return consts[nconstant];
    }
    if (t == 1) {
        int nvar = ??;
        return vars[nvar];
    }
    if (t == 2) {
        int t1 = expInteger(nvars, nconsts, bnd-1, vars, consts);
        int t2 = expInteger(nvars, nconsts, bnd-1, vars, consts);
        return t1 + t2;
    }
    if (t == 3) {
        int t1 = expInteger(nvars, nconsts, bnd-1, vars, consts);
        int t2 = expInteger(nvars, nconsts, bnd-1, vars, consts);
        return t1 * t2;
    }
    if (t == 4) {
        bit condition = expBoolean(nvars, nconsts, bnd-1, vars, consts);
        int t1 = expInteger(nvars, nconsts, bnd-1, vars, consts);
        int t2 = expInteger(nvars, nconsts, bnd-1, vars, consts);
        return condition ? t1:t2;
    }
}

void aux(int x, int y, int out) {
    int[3] ncons = [-1,0,1];
    int[2] nvars = [x,y];
    assert expInteger(2, 3, 3, nvars, ncons) == out;
}


harness void experiment1(){
    
    aux(5, 5, 15);
    aux(8, 3, 14);
    aux(1234, 227, 1688);
}



/*
harness void experiment2(){
   
    aux(10, 7, 17);
    aux(4, 7, -7);
    aux(10, 3, 13);
    aux(1, -7, -6);
    aux(1, 8, -8);
}
*/